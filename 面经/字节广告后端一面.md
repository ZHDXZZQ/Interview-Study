# 2024/8/20 字节广告后端一面
1. 自我介绍
2. 介绍项目-混排，详细架构以及优化手段
3. 重构迁移都是有风险的，你是如何保证平滑迁移，对线上影响较小的呢
4. 描述一下我们打开一个文件到读数据，操作系统是如何定位到文件的？
    1. 文件路径分析
    2. 查找目录项，找到FCB，定位inode
    3. 磁盘块定位，逻辑存储、物理存储。（如FAT表和索引节点等）
    4. 磁盘控制器寻道
    5. 读取数据到内存缓冲区，在FCB中维护文件指针
5. 文件的逻辑结构是什么？
6. Linux里的IO多路复用有哪些？
7. epoll中的两个模式有什么区别？什么场景下如何选择？
    - 水平触发LT
        - 工作原理：当文件描述符处于“可读”或“可写”状态时，epoll 会一直通知你，即使你没有立即处理该事件。只要条件满足（比如有数据可读），epoll_wait 就会返回该事件。
        - 适用场景：LT 模式下编程相对简单，不容易丢失事件，适用于需要确保处理每一个事件的场景。大部分应用程序使用的都是 LT 模式。
        - 缺点：可能会导致重复的通知，程序可能会多次收到同一个事件的通知，如果处理不当可能会导致效率低下。
    - 边缘触发ET
        - 工作原理：epoll 只在文件描述符状态发生变化时通知你，且仅通知一次。比如，当一个 socket 从不可读变为可读时，epoll_wait 会返回事件，但如果你没有读取所有数据，之后即使 socket 仍然有数据可读，epoll_wait 也不会再通知你，除非状态再次发生变化。
        - 适用场景：ET 模式更高效，因为它减少了系统调用的次数，适合高性能的服务器应用程序。在这种模式下，需要非阻塞 IO 配合使用，并且每次收到通知后，必须处理尽可能多的事件。
        - 缺点：如果处理不当，可能会导致事件丢失，比如程序没有及时处理事件，错过了某些通知。
    - LT 模式适合那些对处理事件的实时性要求不高，但必须确保事件不会丢失的场景，比如简单的网络服务。
    - ET 模式适合对性能要求较高的场景，比如高并发服务器，需要在每次事件通知后处理尽可能多的数据，以减少系统调用的开销。
    - 总之，LT 模式更安全，ET 模式更高效。根据具体的应用场景和对性能的要求来选择合适的模式。
8. 进程和线程的区别
9. Linux环境下如何创建子进程？fork()
10. 一个python代码，解释一下输出结果
    ```python
    from multiprocessing import Process
    from time import sleep

    f = open("file.txt", "w")  # 打开文件

    def work():
        f.close()  # 在子进程中关闭文件

    def main():
        f.write('87654321\n')  # 写入数据

        p = Process(target=work)  # 创建子进程
        p.start()  # 启动子进程
        sleep(0.2)  # 等待子进程运行0.2s
        f.close()

    if __name__ == "__main__":
        main()
    # 解释：父进程往文件中写入87654321，写入了缓冲区，子进程共享父进程的缓冲区
    # 进入子进程关闭文件描述符，会强制清空缓冲区写入文件中
    # 而父进程也会写入，所以右两行87654321
    # 但是，搜索结果是报两次关闭文件描述符的异常，而且子进程不会共享父进程的缓冲区
    ```
11. 手撕：最小操作次数：给定一个数组，和一个目标值x，每次可以从数字最左边或最右边的元素删除一个数字，将x减去删去的这个数字，如果x可以减为0，则返回最少操作次数，否则返回-1。数字都是非负整数，说一下时空复杂度。
    ```C++
    // 题目：
    // 给定一个数组，和一个目标值x，
    // 每次可以从数组最左边或最右边的元素删除一个数字，将x减去删去的这个数字，
    // 重复任意次上述操作，如果x可以减为0，则返回最少操作次数，否则返回-1。
    // 数字都是非负整数

    /*
        思路： dfs回溯，时间O2^n，空间On，想想优化思路
        1. 每次都要对两边做尝试，然后回溯，每次都要计算到底
    */
    // 优化：滑动窗口，时间On，空间On

    #include <deque>
    #include <vector>
    #include <iostream>

    using namespace std;

    const int INF = 1e9;
    int res = INF;

    void dfs(deque<int>& deq, int x, int cur_res) {
        if (x == 0) {   // 如果x为0，则找到了一个结果
            res = min(res, cur_res);    // 取操作最小值
        } else if (x < 0) { // 如果已经小于0，则不可能加回来，则返回
            return;
        }
        int l = deq.front();
        int r = deq.back();
        deq.pop_front();
        dfs(deq, x - l, cur_res + 1);   // 计算取左边的情况
        deq.push_front(l);              // 回溯
        deq.pop_back();
        dfs(deq, x - r, cur_res + 1);   // 计算取右边的情况
        deq.push_back(r);               // 回溯
        return ;
    }

    int main() {
        vector<int> nums = {1, 2, 3, 4, 5};
        int x = 5;
        deque<int> deq;
        for (auto& num : nums) {
            deq.push_back(num);
        }
        dfs(deq, x, 0);
        if (res == INF) {
            cout << -1;
        } else {
            cout << res;
        }
        return 0;
    }
    ```
12. 说一下TCP的三次握手和四次挥手
13. 为什么不能是三次挥手？
14. TCP的重发机制是什么？
15. 反问：业务及组件：交易支付java，具体工作内容是由大池子再分配，mysql、redis、字节自研的、spring
16. 反问：需求量：产品70%，基建30%，10：30-21：30
17. 反问：base：融中心
# 2. 动态多态是怎么实现的？
C++ 中的多态是一种让同一个接口或函数在不同对象的上下文中表现出不同行为的特性。
多态在 C++ 中主要通过 **虚函数** 实现，虚函数利用 **虚函数表（vtable）** 和 **虚指针（vptr）** 机制来支持多态行为。

### C++ 多态的实现机制

1. **虚函数**：
   - 当在基类中使用关键字 `virtual` 声明一个成员函数时，C++ 会为这个函数创建一个虚函数表（vtable）。
   - 虚函数允许派生类重写基类中的函数，以实现不同的行为。如果没有重写，则会调用基类的虚函数。

2. **虚函数表（vtable）**：
   - 虚函数表是一个函数指针数组，用于存储类中所有虚函数的地址。
   - 每个包含虚函数的类都有一个虚函数表，表中保存该类的所有虚函数的地址。
   - 如果一个派生类重写了基类的虚函数，那么虚函数表中相应位置的指针将指向派生类中的重写函数。

3. **虚指针（vptr）**：
   - 每个对象（包含虚函数的类对象）都有一个隐藏的虚指针（vptr），它指向该对象所属类的虚函数表。
   - 虚指针在对象构造时由编译器自动初始化，并指向相应类的虚函数表。
   - 当对象调用虚函数时，编译器通过虚指针找到虚函数表，从表中查找具体的函数地址，从而调用正确的函数。

### 多态的实现过程

1. **编译时**：编译器为含有虚函数的类创建虚函数表，为每个对象添加一个虚指针（vptr）。
   
2. **运行时**：当一个对象调用虚函数时，编译器通过该对象的虚指针（vptr）找到虚函数表（vtable），然后通过虚函数表调用对应的函数。这一过程允许基类指针或引用调用派生类重写的函数，从而实现多态。

### 多态的示例

以下是一个简单的多态示例，展示了虚函数和虚函数表的工作方式：

```cpp
#include <iostream>
using namespace std;

// 基类
class Base {
public:
    virtual void show() {  // 虚函数
        cout << "Base class show function" << endl;
    }

    virtual ~Base() = default; // 虚析构函数，避免内存泄漏
};

// 派生类
class Derived : public Base {
public:
    void show() override {  // 重写基类的虚函数
        cout << "Derived class show function" << endl;
    }
};

int main() {
    Base* ptr = new Derived(); // 基类指针指向派生类对象
    ptr->show();  // 调用的是 Derived 的 show()，实现了多态
    delete ptr;   // 正确调用派生类的析构函数
    return 0;
}
```

### 解释代码

1. **`virtual void show()`**：基类 `Base` 中的 `show` 函数是虚函数，编译器会在 `Base` 类中为此函数添加到虚函数表中。
   
2. **派生类 `Derived` 重写 `show()`**：在派生类 `Derived` 中重写了 `show()` 函数，因此 `Derived` 类的虚函数表中将包含指向 `Derived::show()` 的指针。

3. **多态行为**：
   - 在 `main()` 中，`Base* ptr = new Derived();` 用基类指针指向派生类对象。
   - 当调用 `ptr->show()` 时，通过虚指针找到派生类的虚函数表，并调用 `Derived::show()`，实现了多态。

### 多态的类型

- **编译时多态（静态多态）**：通过函数重载和模板实现，不涉及虚函数和虚函数表。
- **运行时多态（动态多态）**：通过虚函数和虚函数表实现，允许基类指针或引用调用派生类重写的函数。

### 关键点

- **虚函数表和虚指针** 是多态的核心实现机制。
- **动态绑定**：函数调用在运行时决定，基于对象的实际类型。
- **虚析构函数**：在基类中定义虚析构函数可以确保删除基类指针时，正确调用派生类的析构函数，避免内存泄漏。

这种机制使得 C++ 能够在运行时正确选择合适的函数调用，从而实现多态行为。
# 3. 纯虚函数是什么？
**纯虚函数**是 C++ 中用于实现抽象类和接口的一种特殊虚函数。
它的主要特点是没有函数体，通常在基类中声明但不实现，强制派生类提供该函数的具体实现。
纯虚函数的存在使得一个类变成抽象类，不能直接实例化。

### 纯虚函数的定义

在 C++ 中，纯虚函数通过在函数声明后加上 `= 0` 来定义，如下所示：

```cpp
class Base {
public:
    virtual void show() = 0;  // 纯虚函数
};
```

### 纯虚函数的特点

1. **没有实现**：纯虚函数只有声明，没有具体的实现。这意味着基类不定义函数的具体操作，而是将实现的责任推给派生类。
   
2. **抽象类**：包含纯虚函数的类称为**抽象类**。抽象类不能被实例化，必须通过派生类继承并实现所有的纯虚函数后，才能创建派生类的对象。

3. **强制重写**：纯虚函数的存在强制所有派生类必须实现这些函数，否则派生类也会变成抽象类，无法实例化。

4. **接口的实现**：纯虚函数可以用来定义接口，类似于其他语言中的接口概念。抽象类可以包含多个纯虚函数，派生类实现这些函数即可实现该接口的所有功能。

### 使用纯虚函数的目的

- **定义接口**：通过纯虚函数定义一个接口，使得不同的派生类可以提供各自的实现。
- **强制实现**：确保派生类必须提供某些函数的实现，从而定义派生类的行为。
- **实现多态**：通过基类指针或引用调用派生类的实现，达到运行时多态的目的。

### 纯虚函数的示例

以下是一个使用纯虚函数的示例，展示了如何创建一个抽象类并通过派生类实现纯虚函数：

```cpp
#include <iostream>
using namespace std;

// 抽象基类
class Shape {
public:
    // 纯虚函数，强制派生类必须实现
    virtual void draw() = 0;   
    virtual double area() = 0; 

    // 虚析构函数，确保正确释放资源
    virtual ~Shape() = default;
};

// 派生类：圆形
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}

    // 实现纯虚函数
    void draw() override {
        cout << "Drawing a Circle" << endl;
    }

    double area() override {
        return 3.14159 * radius * radius;
    }
};

int main() {
    // 使用基类指针指向派生类对象
    Shape* shape1 = new Circle(5.0);

    shape1->draw();  // 调用 Circle 的 draw()
    cout << "Area: " << shape1->area() << endl;

    delete shape1;

    return 0;
}
```

### 解释代码

1. **抽象基类 `Shape`**：
   - `Shape` 类是一个抽象类，包含两个纯虚函数 `draw()` 和 `area()`，它们没有实现，必须由派生类实现。

2. **派生类 `Circle`**：
   - `Circle` 类从 `Shape` 继承，并实现了 `draw()` 和 `area()` 函数，从而可以被实例化。

3. **多态实现**：
   - 在 `main()` 中，通过基类指针 `Shape*` 指向 `Circle` 对象，并调用实现的虚函数，实现多态。

4. **强制实现和统一接口**：
   - 使用纯虚函数确保所有 `Shape` 的派生类都有 `draw()` 和 `area()` 的实现，提供了一个统一的接口，同时避免了在基类中提供不合适的默认实现。

### 总结

- **纯虚函数**强制派生类实现特定函数，确保类设计的灵活性和一致性。
- 纯虚函数使得一个类成为**抽象类**，抽象类不能实例化，必须通过派生类实现。
- 使用纯虚函数可以设计灵活的接口，支持多态行为，帮助代码实现松耦合和扩展性。
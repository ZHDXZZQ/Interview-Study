# 4. 虚函数表的模型是什么样的？
在C++中，**虚函数表（Virtual Table, vtable）** 是实现多态的核心机制。
当一个类包含虚函数时，编译器会为该类生成一个虚函数表，这是一个指针数组，其中每个指针指向类的虚函数实现。
这个机制保证了通过基类指针或引用可以调用派生类的重写函数。

### 虚函数表的模型

1. **虚函数表（vtable）**：
   - 是一个由指向虚函数的指针组成的数组。
   - 每个含有虚函数的类都有自己的虚函数表。虚函数表是全局共享的元素，即每个类全局仅有一个，在编译时就构造完成。
   - 表中每个元素指向该类的虚函数实现。如果一个派生类重写了虚函数，则表中的指针指向派生类的实现。
   - 虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。
   
2. **虚指针（vptr）**：
   - 每个对象包含一个隐藏的指针（称为虚指针或vptr），指向该对象所属类的虚函数表。
   - 虚指针是编译器在创建对象时自动设置的，不需要用户干预。

### 虚函数表的示意图

假设有以下类结构：

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void func1() { cout << "Base::func1" << endl; }
    virtual void func2() { cout << "Base::func2" << endl; }
    virtual ~Base() {}  // 虚析构函数
};

class Derived : public Base {
public:
    void func1() override { cout << "Derived::func1" << endl; }
    void func3() { cout << "Derived::func3" << endl; }  // 非虚函数
};
```

#### 对象内存布局
- **Base 类的虚函数表**：
  - `vtable for Base`:
    - `func1` -> `Base::func1`
    - `func2` -> `Base::func2`
    - `~Base` -> `Base::~Base`
  
- **Derived 类的虚函数表**：
  - `vtable for Derived`:
    - `func1` -> `Derived::func1` (重写了 `Base::func1`)
    - `func2` -> `Base::func2`
    - `~Base` -> `Base::~Base`

#### 内存布局示意图

```
Object of Derived
+--------------------------+
| vptr -> vtable for Derived|    vtable for Derived
+--------------------------+   +---------------------+
| Derived specific members |   | Derived::func1()    | (指向派生类的 func1)
| ...                      |   +---------------------+
+--------------------------+   | Base::func2()       | (继承自基类的 func2)
                               +---------------------+
                               | Base::~Base()       | (虚析构函数)
                               +---------------------+
```

### 工作流程

1. **对象创建**：当创建一个类对象时，编译器会将对象的 `vptr` 设置为指向对应类的 `vtable`。
   
2. **虚函数调用**：当通过基类指针或引用调用虚函数时，程序会通过对象的 `vptr` 找到 `vtable`，然后在 `vtable` 中查找对应的函数指针并调用派生类的实现。

3. **动态绑定**：虚函数表的存在使得调用函数时可以在运行时决定调用哪个版本的函数，从而实现动态多态。

### 总结
- **虚函数表**包含类的虚函数指针，用于支持多态。
- **虚指针**指向类的虚函数表，每个对象都有一个虚指针。
- 虚函数表的设计使得函数调用在运行时进行解析，实现了 C++ 的动态多态性。
- 虚函数的类对象
    1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。
    2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
    3. 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只看到了父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
    4. 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面
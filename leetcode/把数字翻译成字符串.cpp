/*
    思路： 动态规划，时间On，空间On
    dp[i]表示从0到i这么多个字符所能组成的所有的种类的个数
*/

class Solution {
public:
    int solve(string nums) {
        // dfs可以，但是不满足时空复杂度
        int n = nums.size();
        vector<int> dp(n, 0);
        if (nums[0] == '0') {   // 如果开头就是0，该串首位无法翻译成任何字符
            return 0;
        }
        dp[0] = 1;  // 否则的话，第一位1-9一定可以翻译成一个字符
        for (int i = 1; i < n; ++ i) {
            int num = stoi(nums.substr(i - 1, 2));  // 因为字符一定是1-26，所以只需要看两位即可
            if (nums[i] == '0') {   // 如果当前位是0，那么一定是00，10，20，30，....，90
                if (num > 26 || nums[i - 1] == '0') {   // 判断这两个数字是否符合要求
                    return 0;   // 不符合，返回0，因为本位是0，必须和前一位组合，不然的话0本身和0x不能代表任何字符，一定得是10或20
                } else {
                    dp[i] = dp[i - 1];  // 否则的话，10或20合成一个字符，数量与前一个的情况相同
                }
            } else {    // 如果本位不是0
                if (nums[i - 1] == '0') {   // 如果前一位是0，且没有中断，说明前一位0和上上一位组成了10或20
                    dp[i] = dp[i - 1];  // 那么本位一定是单独的一个字符来算，不能和前一位组合
                } else {    // 如果前一位不是0
                    if (num > 0 && num <= 26) { // 如果前一位和本位组成的数字是一个合法数字
                        if (i > 1) {    // 如果当前位于第三个数字及之后
                            dp[i] = dp[i - 1] + dp[i - 2];  // 本位的可能性是前一位加本位的字符，和上上一位加这两位的字符的这两种情况的总情况之和
                        } else {    // 如果是第二个数字，则+1即可，是特殊情况，即前一位加本位，和前一位和本位组成的数字，这两种情况
                            dp[i] = dp[i - 1] + 1;
                        }
                    } else {    // 如果这两位组合超过了合理范围，本位要按单独一个字符插入
                        dp[i] = dp[i - 1];
                    }
                }
            }
        }
        return dp[n - 1];
    }
};
/*
    思路： 动态规划，时间Onm，空间Onm
    1. 只需要考虑当前节点是不是*，做对应判断即可，具体看注释
*/

class Solution {
public:
    bool isMatch(string s, string p) {
        int s_len = s.size();
        int p_len = p.size();
        vector<vector<bool>> dp(s_len + 1, vector<bool>(p_len + 1, false));
        // dp[i][j]表示s的1-i和p的1-j是否可以匹配
        dp[0][0] = true;    // 初始化两个空串一定可以匹配
        s = ' ' + s;    // 前面加空格方便计算
        p = ' ' + p;
        for (int i = 0; i <= s_len; ++ i) { // 遍历s串的每个字符
            for (int j = 1; j <= p_len; ++ j) { // 遍历p串的每个字符，p不必从0开始，因为p为空串的话，和s串一定不匹配
                if (j + 1 <= p_len && p[j + 1] == '*' && p[j] != '*') {
                    continue;   // 如果下一位是*，本位不必处理，因为可以是0个，如果是连续的*，本位需要处理
                }
                if (i && p[j] != '*') { // 如果当前p位置不是*，则要看当前位置是否匹配，和前一个位置有关系，所以i不能等于0
                    dp[i][j] = dp[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
                    // 如果i-1和j-1能匹配，本位也能匹配，那就可以匹配，任意一个条件不能的话就是false
                } else if (p[j] == '*') {   // 如果本位是*，就要看前一位是什么字符
                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'));
                    // 如果i已经可以和j-2匹配了，那么*前面是什么字符都行，因为可以当作是0个该字符
                    // 否则的话，首先要i-1和j是匹配的，也就是上一轮s少一个字符，应该也是和j匹配的，因为这个*可以当作0个字符
                    // 其次，本轮p的j-1要和s的i匹配，这样才能算作本位可以匹配
                }
            }
        }
        // 遇到连续的*，其实可以把连续的*去掉再判断，也可以当作最前面的*前面的字符来判断，建议前者，即开头先对p串做精简
        return dp[s_len][p_len];
    }
};
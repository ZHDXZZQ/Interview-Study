//思路： 基础算法：快速幂， 时间Ologn，空间O1
//1. 如果要求x的19次，我们可以理解为求 x的16次* x的2次* x，而原本我们需要乘19次
//2. 对于n，我们拆分成2进制，每次需要乘的时候乘入即可
//3. 举例，求3的19次，其实我们只需要3的16次，3的2次和3的1次
//4. 因此，我们对19拆分成二进制10011，第一次我们x3，然后3x3=9
//5. 第二次，我们x9，然后9x9=81
//6. 第三次，二进制为0，不乘，但是基数再平方，即81x81=3^8
//7. 第四次，二进制还是为0，不乘，基数平方，得3^16
//8. 第五次，二进制为1，乘3^16，结束

class Solution {
public:
    double myPow(double x, int n) {
        double res = 1;
        for (int k = abs(n); k > 0; k >>= 1) {  //n可能为负，我们先算正的n次方
            if (k & 1) {    //如果k的二进制最后一位为1
                res *= x;   //结果乘该数
            }   
            x *= x;         //x乘自己，相当于x的4次变8次，8次变16次
        }                   //如果k还没结束，则k除以2，即二进制右移一位
        if (n < 0) {        //如果n为负，求个倒数即可
            res = 1 / res;
        }
        return res;
    }
};
// 思路： 二进制运算的数学思想，时间Ologn（最多32次），空间O1
// 1. 首先这两个数是正数，那么这两个正数比较他们两个不需要考虑最高位符号位
// 2. 两个数的二进制有相同的前缀，要么前面都是0，要么0中带有1
// 3. 举例子，left为xxyxx1abc，right为xxyxx0def，那么前面的5位都相同
// 4. 这两个数相与，前面的xxyxx一定不变，因此这几个数可以按权重先加上（0不用加）
// 5. 从第一个不同的数之后，后面可能相同可能不同，那么取两个极端值
// 6. left一定比xxyxx1000大吧，right一定比xxyxx0111小吧。
// 7. 也就是说，xxyxx1000和xxyxx0111在left和right之间，而这两个数相与得xxyxx0000
// 8. 也就是说，无论其他数字还有谁，他们的前缀一定不会改变，并且从第一个不同的位开始，后面一定全0
// 9. 因此只需要计算xxyxx0000的真值，从前往后判断相同的位并按位权相加即可，后面的就不管了

class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int res = 0;
        for (int i = 30; i >= 0; -- i) {    //都为正数且最大为2的31次方-1，假设为最大值，即0+31个1，此时也只需要右移动30位即可获取最高数位
            int l = left >> i & 1;  //每次将这两个数右移动i位
            int r = right >> i & 1;
            if (l == r) {           //判断这两位是否一致
                if (l == 1 && r == 1) { //如果一致且为1，那就加上这个权重的值
                    res += pow(2, i);
                }
            } else {        //碰到第一个不一致的数，退出
                break;
            }
        }
        return res;     //当前加起来的值即为答案
    }
};
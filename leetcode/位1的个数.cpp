// 解法1思路：模拟十进制转换二进制，时间Ologn，空间O1
// 1. 每次除2取余，余数即二进制的当前位，直到目标数为0

class Solution {
public:
    int hammingWeight(uint32_t n) { //因为n为无符号整数，所以当作是一个非负整数处理即可，不考虑负数
        int res = 0;
        while(n) {                  //循环，直到n为0
            if(n % 2 == 1) ++ res;  //对n除2取余，如果余数为1，答案增1
            n /= 2;                 //n除2
        }
        return res;
    }
};


// 解法2思路：cpp库中的lowbit函数实现，时间Os，空间O1，其中s为n的二进制中的1的个数
// 1. 利用计算机的底层原理，根据补码的性质来做这道题，因为计算机中对于所有数的计算都当作补码处理，只是解读成真值时采用不同的规则
// 2. 比如一串计算机中的8位的二进制数，10010010，如果时有符号类型，第一位被解释为符号位，而计算机中都是以补码存放，我们求出原码，即除了符号位以外，逐位取反再+1，得11101110，真值为-（2+4+8+32+64），即-110
// 3. 而10010010用无符号整数来解释即为128+16+2 = 146，本题得uint32_t就是无符号整数，所以都可以看做非负整数
// 4. 那么利用补码的这一性质可知，在计算机中对任一数求负，对于底层表示来说，如果这个数为负数，即上述补码求原码的操作外连同符号位一起取反，即所有位取反+1
// 5. 如果这个数为正数，他的补码即为原码，求负则为符号位取反，再求补码得除符号位所有位取反+1
// 6. 综上所述，任一数求负，都是所有位按位取反+1，而这里我们无需管他是解读成正数还是负数，只需要关心其底层的二进制变化即可
// 7. 因此，假设某数的二进制表示为10010010，其全部位按位取反得01101101，+1得01101110，此时相与得00000010，即2，可见这里得到的结果只保留了最低位的1
// 8. 利用计算机补码运算的这个性质，我们可以得到x&-x得到的是其二进制表示的最低位的1，这也就是lowbit函数
// 9. 每次求出其lowbit的结果并减去，则每次会把最低位的1减去，当减到0时，其做减法的次数恰好为1的个数

class Solution {
public:
    uint32_t lowbit(uint32_t& x) {
        return x & -x;
    }

    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n) {
            n -= lowbit(n);
            ++ res;
        }
        return res;
    }
};
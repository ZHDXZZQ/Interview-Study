/*
    思路： 环形链表II的解法，时间On，空间O1
    1. 将nums中的每个下标做为一个节点，每个数组的值看作一个指向其值节点的指针
    2. 因为一定存在重复数，因此一定成环
    3. 因为每个值都在1-n之间，因此0一定是链表的起点，且0节点不在环中，因此可以应用求环形链表的环起点的方法
    4. 具体思路不再赘述
*/

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0;   // 快慢指针
        int fast = 0;
        while ((slow == 0 && fast == 0) || slow != fast) {  // 因为存在环，所以快慢指针遍历，一定会重合
            slow = nums[slow];
            fast = nums[nums[fast]];
        }   // 此时slow和fast均指向同一个节点
        slow = 0;       // 将其中一个节点调回到头节点
        while (slow != fast) {  // 两个指针同步遍历
            slow = nums[slow];
            fast = nums[fast];
        }   // 再次相遇的节点就是环的起点，也就是这里的重复数
        return slow;
    }
};

// 我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，
// 根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。
// 这里简单解释为什么后面将 slow 放置起点后移动相遇的点就一定是答案了。
// 假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c=L，
// 其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了 a+b 步，快指针走了 2(a+b) 步。
// 从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，
// 可以得到
// 2(a+b)=a+b+kL
// 解得 a=kL−b，整理可得
// a=(k−1)L+(L−b)=(k−1)L+c
// 从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，
// 快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。
// 两个指针在环的入口相遇，相遇点就是答案。

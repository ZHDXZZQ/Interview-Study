// 思路： 位运算，时间O32，认为是O1，空间O1
// 1. 对于给定的二进制数，每次从右边摘下来当前位，然后补到结果中，结果左移
// 2. 例如对于1101，即13，我们先摘下来1，放到结果中，当前结果为1
// 3. 然后结果左移，即x2，但是这里我们用二进制表示即10，此时将1101倒数第二位0摘下来加入结果中，结果为10，即十进制的2
// 4. 然后结果左移，即100，此时将1101的倒数第三位摘下来加入结果中，即101
// 5. 最后结果右移即1010，再加上最后一个1，即1011，成功翻转，十进制表示为11
// 6. 对于翻转，可以用n >> k，即n右移k位，此时与1相与，如果该为为1则为1，否则则为0
// 7. 将该位加到结果中，结果左移1位，或x2
// 8. 这里有32位，只需要移动32位即可

class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; ++ i) {
            res = (res << 1) + ((n >> i) & 1);  //结果左移一位即x2，n右移n位与1取出当前从右往左数第i位的值加到结果中
        }
        return res;
    }
};
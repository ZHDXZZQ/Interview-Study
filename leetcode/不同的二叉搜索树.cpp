/*
    思路： 动态规划，时间On²，空间On
    1. 用dp记录有n个结点的二叉搜索树的形态个数
    2. 对于n个结点的二叉搜索树，依次让每个节点作为根节点，构造两边不同节点数的子树的个数相乘相加即可
*/

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;  // 0个结点只用作辅助计算
        dp[1] = 1;  // 1个结点的二叉搜索树只有一种形态
        for (int i = 2; i <= n; ++ i) { // 从2开始，遍历到n个结点的二叉搜索树
            for (int l = 0; l < i; ++ l) {  // l代表左子树的节点个数
                int r = i - l - 1;      // r代表右子树的节点个数
                dp[i] += dp[l] * dp[r]; // 当前n个结点的树形情况加上左右各种情况的组合数
            }
        }
        return dp[n];
    }
};
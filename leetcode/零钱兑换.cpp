// 思路： 动态规划，完全背包问题，时间Omn，空间Om，其中m表示总额，n表示硬币种类
// 1. 利用动态规划，创建一个dp数组，其每个位置的含义是，凑够当前下标所需要的所有硬币的最小数量
// 2. 然后遍历所有硬币种类，计算每次利用该种类硬币凑够所有面额所需要花费的最小数量
// 3. 最后返回凑够总额的个数，如果无法凑够总额则返回-1

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, 1e8);            //dp数组，初始化总额+1的大小，可以直接用下标表示金额，并且有0元这个初始化。你知道为什么不用INT_MAX作为默认值吗？
        int n = coins.size();
        dp[0] = 0;              //初始化dp数组，表示凑够0元只需要花费所有硬币0个
        for (int i = 0; i < n; ++ i) {      //遍历每种面额的硬币
            int& per_val = coins[i];        //当前面额
            for (int j = per_val; j <= amount; ++ j) {      //从当前面额开始一直遍历到总额，记录在使用当前面额和已遍历过面额的硬币的情况下，凑够每种面额所需要的最少的硬币数量，j之前无法用j凑
                dp[j] = min(dp[j], dp[j - per_val] + 1);    //用当前面额和已遍历过面额的硬币的情况下，凑够面额j所需要的硬币数量为 （凑够j-该面额）的硬币所需要的最小数量+j面额的硬币（即1个），与只使用前面的面额硬币凑j所需要的最少数量的最小值
            }
        }
        if (dp[amount] == 1e8) { return - 1; }              //如果凑够总额所需要的最少硬币数量为初始值，则说明没有硬币可以凑成总额
        return dp[amount];              //反之返回最小数量
    }
};


// 解答：如果使用INT_MAX作为默认值，+1时会超出int范围，导致返回的最小值成为INT_MIN
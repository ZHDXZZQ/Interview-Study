// 思路： 贪心，时间On，空间O1
// 1. 首先用一个数组存储每个字符在字符串中最后一次出现的位置
// 2. 遍历整个字符串，记录当前子串的首尾，然后判断当前所指字符和当前子串的尾的关系
// 3. 如果当前子串的尾就是该字符出现的最后一个位置，说明当前子串内的所有字符，在当前位置之后不可能再出现，那么这个位置就可以作为第一个最短子串，计入答案
// 4. 否则的话，更新当前子串的尾，表明当前字符在后面还会出现，当前子串还不能算作一个最小子串

class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> last_pos(26, 0);
        int n = s.size();
        for (int i = 0; i < n; ++ i) {      // 记录每个字符出现的最后一个位置
            char& c = s[i];
            last_pos[c - 'a'] = i;
        }
        vector<int> res;
        int start = 0, end = 0;     // 记录当前子串的首尾
        for (int i = 0; i < n; ++ i) {  // 遍历所有字符
            char& c = s[i];
            end = max(end, last_pos[c - 'a']);  // 利用当前字符最后出现的位置和当前子串的尾比较
            if (end == i) { // 如果当前位置恰好就是当前子串的尾巴，说明在遍历当前子串后发现，当前子串的所有字符在当前尾部之后不会再出现
                res.push_back(end - start + 1); // 那么就可以把当前子串作为一个最短子串插入，以使得数量最多且不会有两个子串有重复字符
                start = end + 1;    // 开始记录下一个子串
            }
        }
        return res;
    }
};
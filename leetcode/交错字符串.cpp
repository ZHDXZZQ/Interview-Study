// 思路： 动态规划， 时间Omn，空间On，m和n分别为s1和s2的长度
// 1. dp[i][j]表示由s1的前i个字符和s2的前j个字符可不可以构成s3的前i+j个字符
// 2. 本题利用滚动数组优化了空间，所以推导关系不好用纯文字描述
// 3. 建议读者看一下官方题解，或者优化前的解法更易于理解

class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.size();
        int n = s2.size();
        if (m + n != s3.size()) { return false; }   //如果长度不匹配，则不可能构成
        s1 = " " + s1;  //每个前面带一个空格，方便初始化状态
        s2 = " " + s2;
        s3 = " " + s3;
        vector<bool> dp(n + 1, false);  //dp[j]表示利用s2的前j个字符和当前轮次的s1的前i个字符，能否组成s3的前i+j个字符
        dp[0] = true;   //初始化状态位true
        for (int i = 0; i <= m; ++ i) { //遍历s1和s2的每一个字符
            for (int j = 0; j <= n; ++ j) {
                // 对于i为0和j为0的情况无需处理
                if (i > 0 && s1[i] != s3[i + j]) {  
                    // 判断用s1的前i个字符和s2的前j个字符可否构成
                    // 此处利用了滚动数组优化了空间，当前dp[j]存储的就是使用s1的i-1个字符和s2的j个字符能否构成s3的前i+j个
                    // 那么其实如果本来就可以现在还可以，这里没必要变；如果本来就不可以这里也不需要变；如果本来可以现在不可以了，需要变为false给下一轮使用，所以只判断不等于的情况
                    dp[j] = false;
                }
                if (j > 0 && s2[j] == s3[i + j]) {
                    // 对于j，我们判断的是相等的情况，它利用的是刚刚i判断出的情况和j-1的情况，所有利用是否等于判断
                    dp[j] = dp[j] || dp[j - 1];
                }
            }
        }
        return dp[n];   //此时存储的就是s1的全部字符和s2的全部字符能否构成
    }
};
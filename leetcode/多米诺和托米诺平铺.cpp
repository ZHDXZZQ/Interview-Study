/*
    思路： 状态压缩DP，时间On，空间On，可以用矩阵快速幂实现时间Ologn，空间O1
    dp[i][j]表示第i列及之后都未覆盖瓷砖，且第i-1列之前都已经铺满了瓷砖，第i-1列可能铺了也可能没铺，看具体状态推算当前第i列各种状态可能的情况
    j表示当前第i列可能的状态，0为上下两个瓷砖都为空，1为上瓷砖被覆盖，2为下瓷砖被覆盖，3为上下瓷砖都被覆盖
    1. 初始化dp[0][x]时为第0列，是不存在的一列，我们默认它上下都被覆盖，即该列瓷砖已没有可用空间
    2. 每次计算到第i列瓷砖各状态可能的铺法
    3. 返回最后一列都铺满的情况
    注意：当第i列全部铺满时，第i-1列一定已经全部铺满才行
*/

const long mod = 1e9 + 7;
class Solution {
public:
    int numTilings(int n) {
        vector<vector<long>> dp(n + 1, vector<long>(4, 0));    // 初始化n+1个vec，每个vec存储当前列4种状态下能铺的全部方法
        dp[0][3] = 1;   // 默认第0列铺满，其他3种情况为0表示不存在该情况
        for (int i = 1; i <= n; i++) {  // 从第一列判断到最后一列
            dp[i][0] = dp[i - 1][3];    // 当前列为空的情况只能是前一列都铺满了，不然这一列必须填充（为了保障上一列填满，多出的部分一定会到这一列来）
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod; // 当前列上瓷砖被覆盖，可能是上一列为空，贴了个 厂 字形的；或者上一列下边被覆盖，上面贴个一字形的
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod; // 当前列下瓷砖被覆盖，可能是上一列为空，贴了个 L 字形的；或者上一列上边被覆盖，下面贴一个一字型的
            dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod;  
            // 当前列都被覆盖，可能是上一列为空，贴两个一字型；可能是上一列上边被覆盖，贴一个L轴对称字形的；可能是上一列下边被覆盖，贴一个 厂 轴对称字形的；
            // 也可能是上一列全被覆盖，贴一个1字形的
        }
        return dp[n][3];    // 返回第n列全被覆盖（此时前面一定全部被覆盖）的可能的情况总数
    }
};
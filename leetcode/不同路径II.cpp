// 思路：动态规划，时间Onm，空间O1
// 1. 原地动态规划，图中每个结点的含义是，从左上角到当前结点可能拥有的路径数量
// 2. 将当前数组初始化更新，因为只能向右和向下走，所以第一行和第一列的每个位置初始化最大都是1，因为从头过来的路径只有1条，但是如果中间碰到障碍物，那么障碍物及之后都不可到达，因此置为0
// 3. 对于非第一行和第一列的格子，如果不是障碍物，则初始化为-1，这个无所谓，只是方便判断
// 4. 如果是障碍物，记为0，这方便动规过程中直接进行计算
// 5. 最后，对于每个格子，只需要计算左边格子的路径种类和上边格子的路径种类之和，即可

class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        int flag = 0;           //用于初始化第一行和第一列时，判断该路径上是否有障碍物，为0表示没有障碍物
        int start = obstacleGrid[0][0];     //记录第一个单元格，因为这个单元格也有可能是0或1，但是初始化两边时都需要进行更新用于判断是否为障碍物，因此需要记录方便另一边初始化不被误导
        for (int i = 0; i < m; ++ i) {      //初始化第一列
            if (flag == 0) {                //如果从头到目前为止还没有碰到障碍物
                if (obstacleGrid[i][0] == 1) {  //判断此处是不是障碍物，如果是障碍物
                    flag = 1;                   //则将标志记为1，后面的所有格子都不可达
                    obstacleGrid[i][0] = 0;     //对于不可达的格子，记为0，表示有0条路径可以来到这里
                } else {
                    obstacleGrid[i][0] = 1;     //如果没碰到障碍物且不是障碍物，记为1，表示有1种路径可达这里
                }
            } else {
                obstacleGrid[i][0] = 0;         //如果前面已经有障碍物，则此处不可达，记为0
            }
        }
        flag = 0;                               //初始化第一行前，标记改为0
        obstacleGrid[0][0] = start;             //第一格改为原始的情况，因为如果原本有障碍物，这里是1，如果原本没有障碍物，这里此时还是1（表示1条路径可达），但又不能不判断，因此第二遍判断时重置一下
        for (int i = 0; i < n; ++ i) {          //遍历第一行
            if (flag == 0) {                    //规则同上
                if (obstacleGrid[0][i] == 1) {
                    flag = 1;
                    obstacleGrid[0][i] = 0;
                } else {
                    obstacleGrid[0][i] = 1;
                }
            } else {
                obstacleGrid[0][i] = 0;
            }
        }

        for (int i = 1; i < m; ++ i) {          //遍历非第一行和第一列的其他格子
            for (int j = 1; j < n; ++ j) {
                if (obstacleGrid[i][j] == 0) { obstacleGrid[i][j] = -1; }   //如果当前格子为0表示该格子不是障碍物，记为-1，此处可以记为任意值
                else { obstacleGrid[i][j] = 0; }            //如果当前格子为1，即有障碍物，则记为0，必须为0，这方便待会儿计算
            }
        }

        for (int i = 1; i < m; ++ i) {          //遍历非第一行和第一列的其他格子
            for (int j = 1; j < n; ++ j) {
                if (obstacleGrid[i][j] == -1) { //如果该格子不是障碍物
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];   //计算到达该格子的可能路径，即到达左边格子的路径种类+到达上边格子的路径种类。此时是不是对于障碍物格子来说，0就可以直接运算了？而且-1不产生任何影响
                }
            }
        }
        return obstacleGrid[m - 1][n - 1];      //全部计算完后返回最后一个格子的值，即到达这个格子的所有可能路径。
    }
};
// 本题可参考礼物的最大价值，最小路径和
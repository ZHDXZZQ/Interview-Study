/*
    思路： 动态规划，滚动数组优化，时间Omn，空间On
    1. 对于每个格子，他都是来自于上面的格子和左边的格子，对于第一行和第一列的所有格子，都只有一条直线可走，即到达第一行和第一列的所有格子的路径总数都是1
    2. 对于其他格子，他的路径都是从上面的格子和左边的格子走来，因此到达这里的路径总数都是到达上面的格子和左边的格子的路径和，注意这里无需+1，因为最后一步是必然
    3. 利用滚动数组优化，因为每次只需要上一行的数据和本行左边的数据即可得出
*/

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> rec(n, 1);  // 初始化都是1
        for (int i = 1; i < m; ++ i) {  // 从1行开始，因为0行都是1
            for (int j = 1; j < n; ++ j) {  // 从1列开始，因为所有0列也都是1
                rec[j] += rec[j - 1];   // 当前格子的路径总数等于上方（即本位）+左方的路径总数
            }
        }
        return rec[n - 1];
    }
};